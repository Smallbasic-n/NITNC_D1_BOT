@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using ImagawaYoshimoto2nd1.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityRedirectManager RedirectManager
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

@if (externalLogins.Length == 0)
{
    <div>
        <p>
            使用可能なログイン方法がありません．システム管理者に連絡して下さい．
        </p>
    </div>
}
else
{
    <div class="nav-item px-3">
        <form id="loginform" method="post" action="Account/PerformExternalLogin">
            <AntiforgeryToken/>
            <input type="hidden" name="ReturnUrl" value="@ReturnUrl"/>
            <button id="test1" type="submit" class="nav-link" aria-hidden="true" name="provider" value="@externalLogins[0].Name" title="Microsoftでログイン">
                <span class="bi bi-person-badge-nav-menu" aria-hidden="true"></span> Microsoftでログイン
            </button>
        </form>
    </div>
    <button onclick=@getLocationFromJS>Get Location</button>
}

@code {
    private AuthenticationScheme[] externalLogins = [];
    
    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        externalLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync()).ToArray();
    }
    async Task getLocationFromJS()
    {
        throw new Exception();
        File.WriteAllText("./test.txt",DateTime.Now.ToString("hh:mm:ss t z"));
        Console.WriteLine("Before");
        await JSRuntime.InvokeVoidAsync("getLocation");
        Console.WriteLine("After");
    }
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        JSRuntime.InvokeVoidAsync("window.autoClick");
        return base.OnAfterRenderAsync(firstRender);
    }

}